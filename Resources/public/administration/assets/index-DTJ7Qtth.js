const r='{% block sw_condition_tree %} <div class="sw-condition-tree"> <sw-condition-tree-node v-if="conditionTree" :disabled="disabled" :parent-condition="rootCondition" :condition="conditionTree" :level="0" /> <sw-loader v-else /> </div> {% endblock %}',{Component:a}=Shopware,{EntityCollection:s}=Shopware.Data;a.register("sw-condition-tree",{template:r,inject:["feature"],provide(){return{availableTypes:this.availableTypes,availableGroups:this.availableGroups,createCondition:this.createCondition,insertNodeIntoTree:this.insertNodeIntoTree,removeNodeFromTree:this.removeNodeFromTree,childAssociationField:this.childAssociationField,conditionDataProviderService:this.conditionDataProviderService,conditionScopes:this.scopes,restrictedConditions:this.restrictedConditions}},emits:["conditions-changed","initial-loading-done"],props:{conditionDataProviderService:{type:Object,required:!0},conditionRepository:{type:Object,required:!1,default:null},initialConditions:{type:Array,required:!1,default:null},rootCondition:{type:Object,required:!1,default:null},allowedTypes:{type:Array,required:!1,default:null},scopes:{type:Array,required:!1,default:null},associationField:{type:String,required:!0},associationValue:{type:String,required:!0},associationEntity:{type:Object,required:!1,default:null},childAssociationField:{type:String,required:!1,default:"children"},disabled:{type:Boolean,required:!1,default:!1}},data(){return{conditionTree:null,initialLoadingDone:!1}},computed:{availableTypes(){let i;this.allowedTypes?i=this.allowedTypes.map(t=>this.conditionDataProviderService.getByType(t)):i=this.conditionDataProviderService.getConditions(this.scopes),i.forEach(t=>{t.translatedLabel=this.$tc(t.label)}),i.sort((t,o)=>t.translatedLabel.localeCompare(o.translatedLabel));const e=[];return this.availableGroups.forEach(t=>{i.forEach(o=>{o.group===t.id&&e.push(o),!o.group&&t.id==="misc"&&(e.push(o),o.group="misc")})}),e},rootId(){var i;return((i=this.rootCondition)==null?void 0:i.id)??null},availableGroups(){if(typeof this.conditionDataProviderService.getGroups!="function")return[];const i=Object.values(this.conditionDataProviderService.getGroups());return i.forEach(e=>{e.label=this.$tc(e.name)}),i.sort((e,t)=>e.id==="general"?-1:t.id==="general"||e.id==="misc"?1:t.id==="misc"?-1:e.label.localeCompare(t.label)),i},restrictedConditions(){return typeof this.conditionDataProviderService.getRestrictedConditions!="function"?[]:this.conditionDataProviderService.getRestrictedConditions(this.associationEntity)}},watch:{initialConditions:{immediate:!0,deep:!1,handler(i,e){if(i!==e){if(i==null){this.conditionTree=null;return}this.buildTree()}}}},methods:{buildTree(){let i=this.getRootNodes(this.initialConditions,this.rootId);if(this.needsRootOrContainer(i)){const e=this.applyRoot(i);this.initialConditions.push(e),i=[e]}this.conditionTree=this.createTreeRecursive(i[0],this.initialConditions),this.emitChange([]),this.initialLoadingDone||(this.$emit("initial-loading-done"),this.initialLoadingDone=!0)},createTreeRecursive(i,e){const t=e.filter(o=>o.parentId===i.id).sort((o,n)=>o.position-n.position).map(o=>this.createTreeRecursive(o,e)).filter(o=>!i[this.childAssociationField].has(o.id));return i[this.childAssociationField]=new s(i[this.childAssociationField].source,i[this.childAssociationField].entity,i[this.childAssociationField].context,null,[...t,...i[this.childAssociationField]]),i},getRootNodes(i,e){return i.filter(t=>t.parentId===e)},needsRootOrContainer(i){return i.length!==1||!this.conditionDataProviderService.isOrContainer(i[0])},applyRoot(i){const e=this.createCondition(this.conditionDataProviderService.getOrContainerData(),this.rootId,0);return i.forEach(t=>{t.parentId=e.id}),e},createCondition(i,e,t){let o=this.conditionRepository.create(this.initialConditions.context);return o=Object.assign(o,i,{parentId:e,position:t,[this.associationField]:this.associationValue}),o},insertNodeIntoTree(i,e){if(!i)throw new Error("[sw-condition-tree] Can not insert into non existing tree");this.validatePosition(i,e),i[this.childAssociationField].forEach(t=>{t.position>=e.position&&(t.position+=1)}),i[this.childAssociationField].addAt(e,e.position),this.emitChange([])},removeNodeFromTree(i,e){if(!i)throw new Error("[sw-condition-tree] Can not remove from non existing tree");const t=this.getDeletedIds(e);i[this.childAssociationField].forEach(o=>{o.position>e.position&&(o.position-=1)}),i[this.childAssociationField].remove(e.id),this.emitChange(t)},validatePosition(i,e){(typeof e.position!="number"||e.position<0)&&(e.position=0),e.position>i[this.childAssociationField].length&&(e.position=i[this.childAssociationField].length)},getDeletedIds(i){const e=[];return this.getDeletedIdsRecursive(i,e),e},getDeletedIdsRecursive(i,e){if(!i.isNew()){e.push(i.id);return}i[this.childAssociationField].forEach(t=>{this.getDeletedIdsRecursive(t,e)})},emitChange(i){const e=new s(this.initialConditions.source,this.initialConditions.entity,this.initialConditions.context,this.initialConditions.criteria,[this.conditionTree]);this.$emit("conditions-changed",{conditions:e,deletedIds:i})}}});
