const n='{% block sw_settings_rule_category_tree %} <sw-card class="sw-settings-rule-category-tree" position-identifier="sw-settings-rule-category-tree" > <template #toolbar> {% block sw_settings_rule_category_tree_toolbar %} <sw-card-filter @sw-card-filter-term-change="searchTreeItems" /> {% endblock %} </template> {% block sw_settings_rule_category_tree_component %} <sw-settings-rule-tree ref="swTree" :allow-create-categories="false" :allow-delete-categories="false" :items="categories" after-id-property="afterCategoryId" :sortable="false" @get-tree-items="getTreeItems" @search-tree-items="searchTreeItems" @check-item="onCheckItem" > {% block sw_settings_rule_category_tree_items %} <template #items="{ treeItems, sortable, draggedItem, newElementId, checkItem, translationContext, onChangeRoute, disableContextMenu, }" > {% block sw_settings_rule_category_tree_item %} <sw-settings-rule-tree-item v-for="item in treeItems" :key="item.id" :association="association" :item="item" :sortable="false" should-focus :mark-inactive="true" :hide-action="true" @check-item="checkItem" /> {% endblock %} </template> <template v-if="hideHeadline" #headline > <span></span> </template> <template v-if="hideSearch" #search > <span></span> </template> {% endblock %} </sw-settings-rule-tree> {% endblock %} </sw-card> {% endblock %}',{Criteria:i}=Cicada.Data,l={template:n,compatConfig:Cicada.compatConfig,inject:["repositoryFactory"],emits:["on-selection"],props:{rule:{type:Object,required:!0},association:{type:String,required:!0},categoriesCollection:{type:Array,required:!0},hideHeadline:{type:Boolean,required:!1,default:!1},hideSearch:{type:Boolean,required:!1,default:!1}},data(){return{categories:[],isComponentReady:!1,isFetching:!1}},computed:{categoryRepository(){return this.repositoryFactory.create("category")},treeCriteria(){const e=new i(1,500);return e.getAssociation(this.association).addFilter(i.equals("id",this.rule.id)),e}},watch:{categoriesCollection:{handler(){this.categoriesCollection.entity&&!this.isComponentReady&&!this.isFetching&&Promise.all([this.getTreeItems()]).then(()=>{this.isComponentReady=!0})},immediate:!0}},methods:{searchTreeItems(e){this.getTreeItems(null,e,!0)},onCheckItem(e){this.$emit("on-selection",e)},getTreeItems(e=null,s=null,a=!1){this.isFetching=!0;const r=this.treeCriteria;return r.filters=r.filters.filter(t=>t.type==="equals"&&t.field==="parentId"?!1:!(t.type==="contains"&&t.field==="name")),s&&a&&r.addFilter(i.contains("name",s)),s||r.addFilter(i.equals("parentId",e)),this.categoryRepository.search(r,Cicada.Context.api).then(t=>e===null?(this.categories=t,this.isFetching=!1,Promise.resolve()):(t.forEach(o=>{this.categories.add(o)}),Promise.resolve()))}}};export{l as default};
//# sourceMappingURL=index-o48YVMQN.js.map
